// ignore_for_file: unused_local_variable, avoid_print

import 'package:microsoft_kiota_abstractions/microsoft_kiota_abstractions.dart';

Future<void> main() async {
  // The abstractions package contains all the foundational code on which
  // the serialization packages (and many more) depend.

  // Here is a showcase of some of its components.

  ////////////////////////////////////////////////////////////////////////

  // DateOnly & TimeOnly

  // captures only the date part of a DateTime:
  final today = DateOnly.fromDateTime(DateTime.now());
  // prints value in 'yyyy-MM-dd' format
  print(today.toRfc3339String());

  // captures only the time part of a DateTime (ignores timezone):
  final wallClockTime = TimeOnly.fromDateTime(DateTime.now());
  // prints value in 'HH:mm:ss.SSS' format
  print(wallClockTime.toRfc3339String());

  // there are even extensions to fuse them back together
  final now = today.combine(wallClockTime);

  ////////////////////////////////////////////////////////////////////////

  // HttpHeaders
  // A data structure that behaves like a map, but is key case insensitive (when
  // adding) and preserves the actual key.

  final headers = HttpHeaders();
  headers['Foo'] = {'Bar'};
  print(headers['FOO']); // prints: "Bar"
  print(headers.keys); // prints: ["Foo"]

  ////////////////////////////////////////////////////////////////////////

  // MultipartBody
  // represents a generic, serializable object, that can hold multiple "parts"
  // with different content types

  final body = MultipartBody()
    ..addOrReplace('name', 'text/plain', 'Ricardo')
    ..addOrReplace('settings', 'application/json', {
      'themeMode': 'system',
      'accentColor': '#33aa66',
    });

  print(body.getPartValue('name')); // prints: "Ricardo"
  body.removePart('name'); // only part left is "settings"

  ////////////////////////////////////////////////////////////////////////

  // RequestInformation
  // An abstract, HTTP-client-agnostic way to represent HTTP requests.

  final request = RequestInformation(
    httpMethod: HttpMethod.get,
    pathParameters: {'id': 123},
    urlTemplate: 'https://example.com/{id}/foo',
  );

  ////////////////////////////////////////////////////////////////////////

  // AuthenticationProvider
  // Most APIs need some kind of authentication. Kiota provides some commonly
  // used AuthenticationProviders in this package.

  // will never provide any authentication
  const anon = AnonymousAuthenticationProvider();
  await anon.authenticateRequest(request); // does nothing

  final apiKey = ApiKeyAuthenticationProvider(
    apiKey: 'my-awesome-secure-key',
    parameterName: 'X-ApiKey',
    keyLocation: ApiKeyLocation.header,
  );
  await apiKey.authenticateRequest(request); // adds a 'X-ApiKey' header

  const tokenProvider = _DummyAccessTokenProvider(token: 'my-bearer-token');
  const bearer = BaseBearerTokenAuthenticationProvider(tokenProvider);
  // adds a 'Authentication' header with a 'Bearer <token>' value
  await bearer.authenticateRequest(request);

  ////////////////////////////////////////////////////////////////////////

  // There are a lot more components, most of which will be used by the code
  // generated by Kiota.
}

class _DummyAccessTokenProvider extends AccessTokenProvider {
  const _DummyAccessTokenProvider({required this.token});

  final String token;

  @override
  AllowedHostsValidator get allowedHostsValidator => AllowedHostsValidator();

  @override
  Future<String> getAuthorizationToken(
    Uri uri, [
    Map<String, Object>? additionalAuthenticationContext,
  ]) {
    return Future.value(token);
  }
}
